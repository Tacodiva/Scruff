{"version":3,"file":"dist.js","sources":["webpack://AudioEngine/webpack/universalModuleDefinition","webpack://AudioEngine/webpack/bootstrap","webpack://AudioEngine/./node_modules/audio-context/index.js","webpack://AudioEngine/./node_modules/events/events.js","webpack://AudioEngine/./node_modules/global/window.js","webpack://AudioEngine/./node_modules/microee/index.js","webpack://AudioEngine/./node_modules/minilog/lib/common/filter.js","webpack://AudioEngine/./node_modules/minilog/lib/common/minilog.js","webpack://AudioEngine/./node_modules/minilog/lib/common/transform.js","webpack://AudioEngine/./node_modules/minilog/lib/web/array.js","webpack://AudioEngine/./node_modules/minilog/lib/web/console.js","webpack://AudioEngine/./node_modules/minilog/lib/web/formatters/color.js","webpack://AudioEngine/./node_modules/minilog/lib/web/formatters/minilog.js","webpack://AudioEngine/./node_modules/minilog/lib/web/formatters/util.js","webpack://AudioEngine/./node_modules/minilog/lib/web/index.js","webpack://AudioEngine/./node_modules/minilog/lib/web/jquery_simple.js","webpack://AudioEngine/./node_modules/minilog/lib/web/localstorage.js","webpack://AudioEngine/./node_modules/startaudiocontext/StartAudioContext.js","webpack://AudioEngine/(webpack)/buildin/global.js","webpack://AudioEngine/src/ADPCMSoundDecoder.js","webpack://AudioEngine/src/ArrayBufferStream.js","webpack://AudioEngine/src/AudioEngine.js","webpack://AudioEngine/src/Loudness.js","webpack://AudioEngine/src/SoundBank.js","webpack://AudioEngine/src/SoundPlayer.js","webpack://AudioEngine/src/StartAudioContext.js","webpack://AudioEngine/src/effects/Effect.js","webpack://AudioEngine/src/effects/EffectChain.js","webpack://AudioEngine/src/effects/PanEffect.js","webpack://AudioEngine/src/effects/PitchEffect.js","webpack://AudioEngine/src/effects/VolumeEffect.js","webpack://AudioEngine/src/index.js","webpack://AudioEngine/src/log.js","webpack://AudioEngine/src/uid.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AudioEngine\"] = factory();\n\telse\n\t\troot[\"AudioEngine\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","'use strict'\r\n\r\nvar window = require('global/window')\r\n\r\nvar OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext\r\nvar Context = window.AudioContext || window.webkitAudioContext\r\n\r\nvar cache = {}\r\n\r\nmodule.exports = function getContext (options) {\r\n\tif (!Context) return null\r\n\r\n\tif (typeof options === 'number') {\r\n\t\toptions = {sampleRate: options}\r\n\t}\r\n\r\n\tvar sampleRate = options && options.sampleRate\r\n\r\n\r\n\tif (options && options.offline) {\r\n\t\tif (!OfflineContext) return null\r\n\r\n\t\treturn new OfflineContext(options.channels || 2, options.length, sampleRate || 44100)\r\n\t}\r\n\r\n\r\n\t//cache by sampleRate, rather strong guess\r\n\tvar ctx = cache[sampleRate]\r\n\r\n\tif (ctx) return ctx\r\n\r\n\t//several versions of firefox have issues with the\r\n\t//constructor argument\r\n\t//see: https://bugzilla.mozilla.org/show_bug.cgi?id=1361475\r\n\ttry {\r\n\t\tctx = new Context(options)\r\n\t}\r\n\tcatch (err) {\r\n\t\tctx = new Context()\r\n\t}\r\n\tcache[ctx.sampleRate] = cache[sampleRate] = ctx\r\n\r\n\treturn ctx\r\n}\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","function M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n","// default filter\nvar Transform = require('./transform.js');\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n","var Transform = require('./transform.js'),\n    Filter = require('./filter.js');\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n","var microee = require('microee');\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n","var Transform = require('../common/transform.js'),\n    cache = [ ];\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  cache.push([ name, level, args ]);\n};\n\n// utility functions\nlogger.get = function() { return cache; };\nlogger.empty = function() { cache = []; };\n\nmodule.exports = logger;\n","var Transform = require('../common/transform.js');\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = require('./formatters/color.js');\nlogger.minilog = require('./formatters/minilog.js');\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js');\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js'),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n","var Minilog = require('../common/minilog.js');\n\nvar oldEnable = Minilog.enable,\n    oldDisable = Minilog.disable,\n    isChrome = (typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent)),\n    console = require('./console.js');\n\n// Use a more capable logging backend if on Chrome\nMinilog.defaultBackend = (isChrome ? console.minilog : console);\n\n// apply enable inputs from localStorage and from the URL\nif(typeof window != 'undefined') {\n  try {\n    Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));\n  } catch(e) {}\n  if(window.location && window.location.search) {\n    var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);\n    match && Minilog.enable(decodeURIComponent(match[1]));\n  }\n}\n\n// Make enable also add to localStorage\nMinilog.enable = function() {\n  oldEnable.call(Minilog, true);\n  try { window.localStorage['minilogSettings'] = JSON.stringify(true); } catch(e) {}\n  return this;\n};\n\nMinilog.disable = function() {\n  oldDisable.call(Minilog);\n  try { delete window.localStorage.minilogSettings; } catch(e) {}\n  return this;\n};\n\nexports = module.exports = Minilog;\n\nexports.backends = {\n  array: require('./array.js'),\n  browser: Minilog.defaultBackend,\n  localStorage: require('./localstorage.js'),\n  jQuery: require('./jquery_simple.js')\n};\n","var Transform = require('../common/transform.js');\n\nvar cid = new Date().valueOf().toString(36);\n\nfunction AjaxLogger(options) {\n  this.url = options.url || '';\n  this.cache = [];\n  this.timer = null;\n  this.interval = options.interval || 30*1000;\n  this.enabled = true;\n  this.jQuery = window.jQuery;\n  this.extras = {};\n}\n\nTransform.mixin(AjaxLogger);\n\nAjaxLogger.prototype.write = function(name, level, args) {\n  if(!this.timer) { this.init(); }\n  this.cache.push([name, level].concat(args));\n};\n\nAjaxLogger.prototype.init = function() {\n  if(!this.enabled || !this.jQuery) return;\n  var self = this;\n  this.timer = setTimeout(function() {\n    var i, logs = [], ajaxData, url = self.url;\n    if(self.cache.length == 0) return self.init();\n    // Test each log line and only log the ones that are valid (e.g. don't have circular references).\n    // Slight performance hit but benefit is we log all valid lines.\n    for(i = 0; i < self.cache.length; i++) {\n      try {\n        JSON.stringify(self.cache[i]);\n        logs.push(self.cache[i]);\n      } catch(e) { }\n    }\n    if(self.jQuery.isEmptyObject(self.extras)) {\n        ajaxData = JSON.stringify({ logs: logs });\n        url = self.url + '?client_id=' + cid;\n    } else {\n        ajaxData = JSON.stringify(self.jQuery.extend({logs: logs}, self.extras));\n    }\n\n    self.jQuery.ajax(url, {\n      type: 'POST',\n      cache: false,\n      processData: false,\n      data: ajaxData,\n      contentType: 'application/json',\n      timeout: 10000\n    }).success(function(data, status, jqxhr) {\n      if(data.interval) {\n        self.interval = Math.max(1000, data.interval);\n      }\n    }).error(function() {\n      self.interval = 30000;\n    }).always(function() {\n      self.init();\n    });\n    self.cache = [];\n  }, this.interval);\n};\n\nAjaxLogger.prototype.end = function() {};\n\n// wait until jQuery is defined. Useful if you don't control the load order.\nAjaxLogger.jQueryWait = function(onDone) {\n  if(typeof window !== 'undefined' && (window.jQuery || window.$)) {\n    return onDone(window.jQuery || window.$);\n  } else if (typeof window !== 'undefined') {\n    setTimeout(function() { AjaxLogger.jQueryWait(onDone); }, 200);\n  }\n};\n\nmodule.exports = AjaxLogger;\n","var Transform = require('../common/transform.js'),\n    cache = false;\n\nvar logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  if(typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;\n  try {\n    if(!cache) { cache = (window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : []); }\n    cache.push([ new Date().toString(), name, level, args ]);\n    window.localStorage.minilog = JSON.stringify(cache);\n  } catch(e) {}\n};\n\nmodule.exports = logger;","/**\n *  StartAudioContext.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2016 Yotam Mann\n */\n(function (root, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([], factory)\n\t } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n\t} else {\n\t\troot.StartAudioContext = factory()\n  }\n}(this, function () {\n\n\t//TAP LISTENER/////////////////////////////////////////////////////////////\n\n\t/**\n\t * @class  Listens for non-dragging tap ends on the given element\n\t * @param {Element} element\n\t * @internal\n\t */\n\tvar TapListener = function(element, context){\n\n\t\tthis._dragged = false\n\n\t\tthis._element = element\n\n\t\tthis._bindedMove = this._moved.bind(this)\n\t\tthis._bindedEnd = this._ended.bind(this, context)\n\n\t\telement.addEventListener(\"touchstart\", this._bindedEnd)\n\t\telement.addEventListener(\"touchmove\", this._bindedMove)\n\t\telement.addEventListener(\"touchend\", this._bindedEnd)\n\t\telement.addEventListener(\"mouseup\", this._bindedEnd)\n\t}\n\n\t/**\n\t * drag move event\n\t */\n\tTapListener.prototype._moved = function(e){\n\t\tthis._dragged = true\n\t};\n\n\t/**\n\t * tap ended listener\n\t */\n\tTapListener.prototype._ended = function(context){\n\t\tif (!this._dragged){\n\t\t\tstartContext(context)\n\t\t}\n\t\tthis._dragged = false\n\t};\n\n\t/**\n\t * remove all the bound events\n\t */\n\tTapListener.prototype.dispose = function(){\n\t\tthis._element.removeEventListener(\"touchstart\", this._bindedEnd)\n\t\tthis._element.removeEventListener(\"touchmove\", this._bindedMove)\n\t\tthis._element.removeEventListener(\"touchend\", this._bindedEnd)\n\t\tthis._element.removeEventListener(\"mouseup\", this._bindedEnd)\n\t\tthis._bindedMove = null\n\t\tthis._bindedEnd = null\n\t\tthis._element = null\n\t};\n\n\t//END TAP LISTENER/////////////////////////////////////////////////////////\n\n\t/**\n\t * Plays a silent sound and also invoke the \"resume\" method\n\t * @param {AudioContext} context\n\t * @private\n\t */\n\tfunction startContext(context){\n\t\t// this accomplishes the iOS specific requirement\n\t\tvar buffer = context.createBuffer(1, 1, context.sampleRate)\n\t\tvar source = context.createBufferSource()\n\t\tsource.buffer = buffer\n\t\tsource.connect(context.destination)\n\t\tsource.start(0)\n\n\t\t// resume the audio context\n\t\tif (context.resume){\n\t\t\tcontext.resume()\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the audio context is started\n\t * @param  {AudioContext}  context\n\t * @return {Boolean}\n\t * @private\n\t */\n\tfunction isStarted(context){\n\t\t return context.state === \"running\"\n\t}\n\n\t/**\n\t * Invokes the callback as soon as the AudioContext\n\t * is started\n\t * @param  {AudioContext}   context\n\t * @param  {Function} callback\n\t */\n\tfunction onStarted(context, callback){\n\n\t\tfunction checkLoop(){\n\t\t\tif (isStarted(context)){\n\t\t\t\tcallback()\n\t\t\t} else {\n\t\t\t\trequestAnimationFrame(checkLoop)\n\t\t\t\tif (context.resume){\n\t\t\t\t\tcontext.resume()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStarted(context)){\n\t\t\tcallback()\n\t\t} else {\n\t\t\tcheckLoop()\n\t\t}\n\t}\n\n\t/**\n\t * Add a tap listener to the audio context\n\t * @param  {Array|Element|String|jQuery} element\n\t * @param {Array} tapListeners\n\t */\n\tfunction bindTapListener(element, tapListeners, context){\n\t\tif (Array.isArray(element) || (NodeList && element instanceof NodeList)){\n\t\t\tfor (var i = 0; i < element.length; i++){\n\t\t\t\tbindTapListener(element[i], tapListeners, context)\n\t\t\t}\n\t\t} else if (typeof element === \"string\"){\n\t\t\tbindTapListener(document.querySelectorAll(element), tapListeners, context)\n\t\t} else if (element.jquery && typeof element.toArray === \"function\"){\n\t\t\tbindTapListener(element.toArray(), tapListeners, context)\n\t\t} else if (Element && element instanceof Element){\n\t\t\t//if it's an element, create a TapListener\n\t\t\tvar tap = new TapListener(element, context)\n\t\t\ttapListeners.push(tap)\n\t\t} \n\t}\n\n\t/**\n\t * @param {AudioContext} context The AudioContext to start.\n\t * @param {Array|String|Element|jQuery=} elements For iOS, the list of elements\n\t *                                               to bind tap event listeners\n\t *                                               which will start the AudioContext. If\n\t *                                               no elements are given, it will bind\n\t *                                               to the document.body.\n\t * @param {Function=} callback The callback to invoke when the AudioContext is started.\n\t * @return {Promise} The promise is invoked when the AudioContext\n\t *                       is started.\n\t */\n\tfunction StartAudioContext(context, elements, callback){\n\n\t\t//the promise is invoked when the AudioContext is started\n\t\tvar promise = new Promise(function(success) {\n\t\t\tonStarted(context, success)\n\t\t})\n\n\t\t// The TapListeners bound to the elements\n\t\tvar tapListeners = []\n\n\t\t// add all the tap listeners\n\t\tif (!elements){\n\t\t\telements = document.body\n\t\t}\n\t\tbindTapListener(elements, tapListeners, context)\n\n\t\t//dispose all these tap listeners when the context is started\n\t\tpromise.then(function(){\n\t\t\tfor (var i = 0; i < tapListeners.length; i++){\n\t\t\t\ttapListeners[i].dispose()\n\t\t\t}\n\t\t\ttapListeners = null\n\n\t\t\tif (callback){\n\t\t\t\tcallback()\n\t\t\t}\n\t\t})\n\n\t\treturn promise\n\t}\n\n\treturn StartAudioContext\n}))","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const ArrayBufferStream = require('./ArrayBufferStream');\nconst log = require('./log');\n\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nconst STEP_TABLE = [\n    7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n    50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230,\n    253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\n    1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327,\n    3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487,\n    12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n];\n\n/**\n * Data used by the decompression algorithm\n * @type {Array}\n */\nconst INDEX_TABLE = [\n    -1, -1, -1, -1, 2, 4, 6, 8,\n    -1, -1, -1, -1, 2, 4, 6, 8\n];\n\nlet _deltaTable = null;\n\n/**\n * Build a table of deltas from the 89 possible steps and 16 codes.\n * @return {Array<number>} computed delta values\n */\nconst deltaTable = function () {\n    if (_deltaTable === null) {\n        const NUM_STEPS = STEP_TABLE.length;\n        const NUM_INDICES = INDEX_TABLE.length;\n        _deltaTable = new Array(NUM_STEPS * NUM_INDICES).fill(0);\n        let i = 0;\n\n        for (let index = 0; index < NUM_STEPS; index++) {\n            for (let code = 0; code < NUM_INDICES; code++) {\n                const step = STEP_TABLE[index];\n\n                let delta = 0;\n                if (code & 4) delta += step;\n                if (code & 2) delta += step >> 1;\n                if (code & 1) delta += step >> 2;\n                delta += step >> 3;\n                _deltaTable[i++] = (code & 8) ? -delta : delta;\n            }\n        }\n    }\n\n    return _deltaTable;\n};\n\n/**\n * Decode wav audio files that have been compressed with the ADPCM format.\n * This is necessary because, while web browsers have native decoders for many audio\n * formats, ADPCM is a non-standard format used by Scratch since its early days.\n * This decoder is based on code from Scratch-Flash:\n * https://github.com/LLK/scratch-flash/blob/master/src/sound/WAVFile.as\n */\nclass ADPCMSoundDecoder {\n    /**\n     * @param {AudioContext} audioContext - a webAudio context\n     * @constructor\n     */\n    constructor (audioContext) {\n        this.audioContext = audioContext;\n    }\n\n    /**\n     * Data used by the decompression algorithm\n     * @type {Array}\n     */\n    static get STEP_TABLE () {\n        return STEP_TABLE;\n    }\n\n    /**\n     * Data used by the decompression algorithm\n     * @type {Array}\n     */\n    static get INDEX_TABLE () {\n        return INDEX_TABLE;\n    }\n\n    /**\n     * Decode an ADPCM sound stored in an ArrayBuffer and return a promise\n     * with the decoded audio buffer.\n     * @param  {ArrayBuffer} audioData - containing ADPCM encoded wav audio\n     * @return {AudioBuffer} the decoded audio buffer\n     */\n    decode (audioData) {\n\n        return new Promise((resolve, reject) => {\n            const stream = new ArrayBufferStream(audioData);\n\n            const riffStr = stream.readUint8String(4);\n            if (riffStr !== 'RIFF') {\n                log.warn('incorrect adpcm wav header');\n                reject();\n            }\n\n            const lengthInHeader = stream.readInt32();\n            if ((lengthInHeader + 8) !== audioData.byteLength) {\n                log.warn(`adpcm wav length in header: ${lengthInHeader} is incorrect`);\n            }\n\n            const wavStr = stream.readUint8String(4);\n            if (wavStr !== 'WAVE') {\n                log.warn('incorrect adpcm wav header');\n                reject();\n            }\n\n            const formatChunk = this.extractChunk('fmt ', stream);\n            this.encoding = formatChunk.readUint16();\n            this.channels = formatChunk.readUint16();\n            this.samplesPerSecond = formatChunk.readUint32();\n            this.bytesPerSecond = formatChunk.readUint32();\n            this.blockAlignment = formatChunk.readUint16();\n            this.bitsPerSample = formatChunk.readUint16();\n            formatChunk.position += 2;  // skip extra header byte count\n            this.samplesPerBlock = formatChunk.readUint16();\n            this.adpcmBlockSize = ((this.samplesPerBlock - 1) / 2) + 4; // block size in bytes\n\n            const compressedData = this.extractChunk('data', stream);\n            const sampleCount = this.numberOfSamples(compressedData, this.adpcmBlockSize);\n\n            const buffer = this.audioContext.createBuffer(1, sampleCount, this.samplesPerSecond);\n            this.imaDecompress(compressedData, this.adpcmBlockSize, buffer.getChannelData(0));\n\n            resolve(buffer);\n        });\n    }\n\n    /**\n     * Extract a chunk of audio data from the stream, consisting of a set of audio data bytes\n     * @param  {string} chunkType - the type of chunk to extract. 'data' or 'fmt' (format)\n     * @param  {ArrayBufferStream} stream - an stream containing the audio data\n     * @return {ArrayBufferStream} a stream containing the desired chunk\n     */\n    extractChunk (chunkType, stream) {\n        stream.position = 12;\n        while (stream.position < (stream.getLength() - 8)) {\n            const typeStr = stream.readUint8String(4);\n            const chunkSize = stream.readInt32();\n            if (typeStr === chunkType) {\n                const chunk = stream.extract(chunkSize);\n                return chunk;\n            }\n            stream.position += chunkSize;\n\n        }\n    }\n\n    /**\n     * Count the exact number of samples in the compressed data.\n     * @param {ArrayBufferStream} compressedData - the compressed data\n     * @param {number} blockSize - size of each block in the data in bytes\n     * @return {number} number of samples in the compressed data\n     */\n    numberOfSamples (compressedData, blockSize) {\n        if (!compressedData) return 0;\n\n        compressedData.position = 0;\n\n        const available = compressedData.getBytesAvailable();\n        const blocks = (available / blockSize) | 0;\n        // Number of samples in full blocks.\n        const fullBlocks = blocks * (2 * (blockSize - 4)) + 1;\n        // Number of samples in the last incomplete block. 0 if the last block\n        // is full.\n        const subBlock = Math.max((available % blockSize) - 4, 0) * 2;\n        // 1 if the last block is incomplete. 0 if it is complete.\n        const incompleteBlock = Math.min(available % blockSize, 1);\n        return fullBlocks + subBlock + incompleteBlock;\n    }\n\n    /**\n     * Decompress sample data using the IMA ADPCM algorithm.\n     * Note: Handles only one channel, 4-bits per sample.\n     * @param  {ArrayBufferStream} compressedData - a stream of compressed audio samples\n     * @param  {number} blockSize - the number of bytes in the stream\n     * @param  {Float32Array} out - the uncompressed audio samples\n     */\n    imaDecompress (compressedData, blockSize, out) {\n        let sample;\n        let code;\n        let delta;\n        let index = 0;\n        let lastByte = -1; // -1 indicates that there is no saved lastByte\n\n        // Bail and return no samples if we have no data\n        if (!compressedData) return;\n\n        compressedData.position = 0;\n\n        const size = out.length;\n        const samplesAfterBlockHeader = (blockSize - 4) * 2;\n\n        const DELTA_TABLE = deltaTable();\n\n        let i = 0;\n        while (i < size) {\n            // read block header\n            sample = compressedData.readInt16();\n            index = compressedData.readUint8();\n            compressedData.position++; // skip extra header byte\n            if (index > 88) index = 88;\n            out[i++] = sample / 32768;\n\n            const blockLength = Math.min(samplesAfterBlockHeader, size - i);\n            const blockStart = i;\n            while (i - blockStart < blockLength) {\n                // read 4-bit code and compute delta from previous sample\n                lastByte = compressedData.readUint8();\n                code = lastByte & 0xF;\n                delta = DELTA_TABLE[index * 16 + code];\n                // compute next index\n                index += INDEX_TABLE[code];\n                if (index > 88) index = 88;\n                else if (index < 0) index = 0;\n                // compute and output sample\n                sample += delta;\n                if (sample > 32767) sample = 32767;\n                else if (sample < -32768) sample = -32768;\n                out[i++] = sample / 32768;\n\n                // use 4-bit code from lastByte and compute delta from previous\n                // sample\n                code = (lastByte >> 4) & 0xF;\n                delta = DELTA_TABLE[index * 16 + code];\n                // compute next index\n                index += INDEX_TABLE[code];\n                if (index > 88) index = 88;\n                else if (index < 0) index = 0;\n                // compute and output sample\n                sample += delta;\n                if (sample > 32767) sample = 32767;\n                else if (sample < -32768) sample = -32768;\n                out[i++] = sample / 32768;\n            }\n        }\n    }\n}\n\nmodule.exports = ADPCMSoundDecoder;\n","class ArrayBufferStream {\n    /**\n     * ArrayBufferStream wraps the built-in javascript ArrayBuffer, adding the ability to access\n     * data in it like a stream, tracking its position.\n     * You can request to read a value from the front of the array, and it will keep track of the position\n     * within the byte array, so that successive reads are consecutive.\n     * The available types to read include:\n     * Uint8, Uint8String, Int16, Uint16, Int32, Uint32\n     * @param {ArrayBuffer} arrayBuffer - array to use as a stream\n     * @param {number} start - the start position in the raw buffer. position\n     * will be relative to the start value.\n     * @param {number} end - the end position in the raw buffer. length and\n     * bytes available will be relative to the end value.\n     * @param {ArrayBufferStream} parent - if passed reuses the parent's\n     * internal objects\n     * @constructor\n     */\n    constructor (\n        arrayBuffer, start = 0, end = arrayBuffer.byteLength,\n        {\n            _uint8View = new Uint8Array(arrayBuffer)\n        } = {}\n    ) {\n        /**\n         * Raw data buffer for stream to read.\n         * @type {ArrayBufferStream}\n         */\n        this.arrayBuffer = arrayBuffer;\n\n        /**\n         * Start position in arrayBuffer. Read values are relative to the start\n         * in the arrayBuffer.\n         * @type {number}\n         */\n        this.start = start;\n\n        /**\n         * End position in arrayBuffer. Length and bytes available are relative\n         * to the start, end, and _position in the arrayBuffer;\n         * @type {number};\n         */\n        this.end = end;\n\n        /**\n         * Cached Uint8Array view of the arrayBuffer. Heavily used for reading\n         * Uint8 values and Strings from the stream.\n         * @type {Uint8Array}\n         */\n        this._uint8View = _uint8View;\n\n        /**\n         * Raw position in the arrayBuffer relative to the beginning of the\n         * arrayBuffer.\n         * @type {number}\n         */\n        this._position = start;\n    }\n\n    /**\n     * Return a new ArrayBufferStream that is a slice of the existing one\n     * @param  {number} length - the number of bytes of extract\n     * @return {ArrayBufferStream} the extracted stream\n     */\n    extract (length) {\n        return new ArrayBufferStream(this.arrayBuffer, this._position, this._position + length, this);\n    }\n\n    /**\n     * @return {number} the length of the stream in bytes\n     */\n    getLength () {\n        return this.end - this.start;\n    }\n\n    /**\n     * @return {number} the number of bytes available after the current position in the stream\n     */\n    getBytesAvailable () {\n        return this.end - this._position;\n    }\n\n    /**\n     * Position relative to the start value in the arrayBuffer of this\n     * ArrayBufferStream.\n     * @type {number}\n     */\n    get position () {\n        return this._position - this.start;\n    }\n\n    /**\n     * Set the position to read from in the arrayBuffer.\n     * @type {number}\n     * @param {number} value - new value to set position to\n     */\n    set position (value) {\n        this._position = value + this.start;\n        return value;\n    }\n\n    /**\n     * Read an unsigned 8 bit integer from the stream\n     * @return {number} the next 8 bit integer in the stream\n     */\n    readUint8 () {\n        const val = this._uint8View[this._position];\n        this._position += 1;\n        return val;\n    }\n\n    /**\n     * Read a sequence of bytes of the given length and convert to a string.\n     * This is a convenience method for use with short strings.\n     * @param {number} length - the number of bytes to convert\n     * @return {string} a String made by concatenating the chars in the input\n     */\n    readUint8String (length) {\n        const arr = this._uint8View;\n        let str = '';\n        const end = this._position + length;\n        for (let i = this._position; i < end; i++) {\n            str += String.fromCharCode(arr[i]);\n        }\n        this._position += length;\n        return str;\n    }\n\n    /**\n     * Read a 16 bit integer from the stream\n     * @return {number} the next 16 bit integer in the stream\n     */\n    readInt16 () {\n        const val = new Int16Array(this.arrayBuffer, this._position, 1)[0];\n        this._position += 2; // one 16 bit int is 2 bytes\n        return val;\n    }\n\n    /**\n     * Read an unsigned 16 bit integer from the stream\n     * @return {number} the next unsigned 16 bit integer in the stream\n     */\n    readUint16 () {\n        const val = new Uint16Array(this.arrayBuffer, this._position, 1)[0];\n        this._position += 2; // one 16 bit int is 2 bytes\n        return val;\n    }\n\n    /**\n     * Read a 32 bit integer from the stream\n     * @return {number} the next 32 bit integer in the stream\n     */\n    readInt32 () {\n        let val;\n        if (this._position % 4 === 0) {\n            val = new Int32Array(this.arrayBuffer, this._position, 1)[0];\n        } else {\n            // Cannot read Int32 directly out because offset is not multiple of 4\n            // Need to slice out the values first\n            val = new Int32Array(\n                this.arrayBuffer.slice(this._position, this._position + 4)\n            )[0];\n        }\n        this._position += 4; // one 32 bit int is 4 bytes\n        return val;\n    }\n\n    /**\n     * Read an unsigned 32 bit integer from the stream\n     * @return {number} the next unsigned 32 bit integer in the stream\n     */\n    readUint32 () {\n        const val = new Uint32Array(this.arrayBuffer, this._position, 1)[0];\n        this._position += 4; // one 32 bit int is 4 bytes\n        return val;\n    }\n}\n\nmodule.exports = ArrayBufferStream;\n","const StartAudioContext = require('./StartAudioContext');\nconst AudioContext = require('audio-context');\n\nconst log = require('./log');\nconst uid = require('./uid');\n\nconst ADPCMSoundDecoder = require('./ADPCMSoundDecoder');\nconst Loudness = require('./Loudness');\nconst SoundPlayer = require('./SoundPlayer');\n\nconst EffectChain = require('./effects/EffectChain');\nconst PanEffect = require('./effects/PanEffect');\nconst PitchEffect = require('./effects/PitchEffect');\nconst VolumeEffect = require('./effects/VolumeEffect');\n\nconst SoundBank = require('./SoundBank');\n\n/**\n * Wrapper to ensure that audioContext.decodeAudioData is a promise\n * @param {object} audioContext The current AudioContext\n * @param {ArrayBuffer} buffer Audio data buffer to decode\n * @return {Promise} A promise that resolves to the decoded audio\n */\nconst decodeAudioData = function (audioContext, buffer) {\n    // Check for newer promise-based API\n    if (audioContext.decodeAudioData.length === 1) {\n        return audioContext.decodeAudioData(buffer);\n    }\n    // Fall back to callback API\n    return new Promise((resolve, reject) => {\n        audioContext.decodeAudioData(buffer,\n            decodedAudio => resolve(decodedAudio),\n            error => reject(error)\n        );\n    });\n};\n\n/**\n * There is a single instance of the AudioEngine. It handles global audio\n * properties and effects, loads all the audio buffers for sounds belonging to\n * sprites.\n */\nclass AudioEngine {\n    constructor (audioContext = new AudioContext()) {\n        /**\n         * AudioContext to play and manipulate sounds with a graph of source\n         * and effect nodes.\n         * @type {AudioContext}\n         */\n        this.audioContext = audioContext;\n        StartAudioContext(this.audioContext);\n\n        /**\n         * Master GainNode that all sounds plays through. Changing this node\n         * will change the volume for all sounds.\n         * @type {GainNode}\n         */\n        this.inputNode = this.audioContext.createGain();\n        this.inputNode.connect(this.audioContext.destination);\n\n        /**\n         * a map of soundIds to audio buffers, holding sounds for all sprites\n         * @type {Object<String, ArrayBuffer>}\n         */\n        this.audioBuffers = {};\n\n        /**\n         * A Loudness detector.\n         * @type {Loudness}\n         */\n        this.loudness = null;\n\n        /**\n         * Array of effects applied in order, left to right,\n         * Left is closest to input, Right is closest to output\n         */\n        this.effects = [PanEffect, PitchEffect, VolumeEffect];\n    }\n\n    /**\n     * Current time in the AudioEngine.\n     * @type {number}\n     */\n    get currentTime () {\n        return this.audioContext.currentTime;\n    }\n\n    /**\n     * Names of the audio effects.\n     * @enum {string}\n     */\n    get EFFECT_NAMES () {\n        return {\n            pitch: 'pitch',\n            pan: 'pan'\n        };\n    }\n\n    /**\n     * A short duration to transition audio prarameters.\n     *\n     * Used as a time constant for exponential transitions. A general value\n     * must be large enough that it does not cute off lower frequency, or bass,\n     * sounds. Human hearing lower limit is ~20Hz making a safe value 25\n     * milliseconds or 0.025 seconds, where half of a 20Hz wave will play along\n     * with the DECAY. Higher frequencies will play multiple waves during the\n     * same amount of time and avoid clipping.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime}\n     * @const {number}\n     */\n    get DECAY_DURATION () {\n        return 0.025;\n    }\n\n    /**\n     * Some environments cannot smoothly change parameters immediately, provide\n     * a small delay before decaying.\n     *\n     * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=1228207}\n     * @const {number}\n     */\n    get DECAY_WAIT () {\n        return 0.05;\n    }\n\n    /**\n     * Get the input node.\n     * @return {AudioNode} - audio node that is the input for this effect\n     */\n    getInputNode () {\n        return this.inputNode;\n    }\n\n    /**\n     * Decode a sound, decompressing it into audio samples.\n     * @param {object} sound - an object containing audio data and metadata for\n     *     a sound\n     * @param {Buffer} sound.data - sound data loaded from scratch-storage\n     * @returns {?Promise} - a promise which will resolve to the sound id and\n     *     buffer if decoded\n     */\n    _decodeSound (sound) {\n        // Make a copy of the buffer because decoding detaches the original\n        // buffer\n        const bufferCopy1 = sound.data.buffer.slice(0);\n\n        // todo: multiple decodings of the same buffer create duplicate decoded\n        // copies in audioBuffers. Create a hash id of the buffer or deprecate\n        // audioBuffers to avoid memory issues for large audio buffers.\n        const soundId = uid();\n\n        // Attempt to decode the sound using the browser's native audio data\n        // decoder If that fails, attempt to decode as ADPCM\n        const decoding = decodeAudioData(this.audioContext, bufferCopy1)\n            .catch(() => {\n                // If the file is empty, create an empty sound\n                if (sound.data.length === 0) {\n                    return this._emptySound();\n                }\n\n                // The audio context failed to parse the sound data\n                // we gave it, so try to decode as 'adpcm'\n\n                // First we need to create another copy of our original data\n                const bufferCopy2 = sound.data.buffer.slice(0);\n                // Try decoding as adpcm\n                return new ADPCMSoundDecoder(this.audioContext).decode(bufferCopy2)\n                    .catch(() => this._emptySound());\n            })\n            .then(\n                buffer => ([soundId, buffer]),\n                error => {\n                    log.warn('audio data could not be decoded', error);\n                }\n            );\n\n        return decoding;\n    }\n\n    /**\n     * An empty sound buffer, for use when we are unable to decode a sound file.\n     * @returns {AudioBuffer} - an empty audio buffer.\n     */\n    _emptySound () {\n        return this.audioContext.createBuffer(1, 1, this.audioContext.sampleRate);\n    }\n\n    /**\n     * Decode a sound, decompressing it into audio samples.\n     *\n     * Store a reference to it the sound in the audioBuffers dictionary,\n     * indexed by soundId.\n     *\n     * @param {object} sound - an object containing audio data and metadata for\n     *     a sound\n     * @param {Buffer} sound.data - sound data loaded from scratch-storage\n     * @returns {?Promise} - a promise which will resolve to the sound id\n     */\n    decodeSound (sound) {\n        return this._decodeSound(sound)\n            .then(([id, buffer]) => {\n                this.audioBuffers[id] = buffer;\n                return id;\n            });\n    }\n\n    /**\n     * Decode a sound, decompressing it into audio samples.\n     *\n     * Create a SoundPlayer instance that can be used to play the sound and\n     * stop and fade out playback.\n     *\n     * @param {object} sound - an object containing audio data and metadata for\n     *     a sound\n     * @param {Buffer} sound.data - sound data loaded from scratch-storage\n     * @returns {?Promise} - a promise which will resolve to the buffer\n     */\n    decodeSoundPlayer (sound) {\n        return this._decodeSound(sound)\n        .then(([id, buffer]) => new SoundPlayer(this, {id, buffer}));\n    }\n\n    /**\n     * Get the current loudness of sound received by the microphone.\n     * Sound is measured in RMS and smoothed.\n     * @return {number} loudness scaled 0 to 100\n     */\n    getLoudness () {\n        // The microphone has not been set up, so try to connect to it\n        if (!this.loudness) {\n            this.loudness = new Loudness(this.audioContext);\n        }\n\n        return this.loudness.getLoudness();\n    }\n\n    /**\n     * Create an effect chain.\n     * @returns {EffectChain} chain of effects defined by this AudioEngine\n     */\n    createEffectChain () {\n        const effects = new EffectChain(this, this.effects);\n        effects.connect(this);\n        return effects;\n    }\n\n    /**\n     * Create a sound bank and effect chain.\n     * @returns {SoundBank} a sound bank configured with an effect chain\n     *     defined by this AudioEngine\n     */\n    createBank () {\n        return new SoundBank(this, this.createEffectChain());\n    }\n}\n\nmodule.exports = AudioEngine;\n","const log = require('./log');\n\nclass Loudness {\n    /**\n     * Instrument and detect a loudness value from a local microphone.\n     * @param {AudioContext} audioContext - context to create nodes from for\n     *     detecting loudness\n     * @constructor\n     */\n    constructor (audioContext) {\n        /**\n         * AudioContext the mic will connect to and provide analysis of\n         * @type {AudioContext}\n         */\n        this.audioContext = audioContext;\n\n        /**\n         * Are we connecting to the mic yet?\n         * @type {Boolean}\n         */\n        this.connectingToMic = false;\n\n        /**\n         * microphone, for measuring loudness, with a level meter analyzer\n         * @type {MediaStreamSourceNode}\n         */\n        this.mic = null;\n    }\n\n    /**\n     * Get the current loudness of sound received by the microphone.\n     * Sound is measured in RMS and smoothed.\n     * Some code adapted from Tone.js: https://github.com/Tonejs/Tone.js\n     * @return {number} loudness scaled 0 to 100\n     */\n    getLoudness () {\n        // The microphone has not been set up, so try to connect to it\n        if (!this.mic && !this.connectingToMic) {\n            this.connectingToMic = true; // prevent multiple connection attempts\n            navigator.mediaDevices.getUserMedia({audio: true}).then(stream => {\n                this.audioStream = stream;\n                this.mic = this.audioContext.createMediaStreamSource(stream);\n                this.analyser = this.audioContext.createAnalyser();\n                this.mic.connect(this.analyser);\n                this.micDataArray = new Float32Array(this.analyser.fftSize);\n            })\n            .catch(err => {\n                log.warn(err);\n            });\n        }\n\n        // If the microphone is set up and active, measure the loudness\n        if (this.mic && this.audioStream.active) {\n            this.analyser.getFloatTimeDomainData(this.micDataArray);\n            let sum = 0;\n            // compute the RMS of the sound\n            for (let i = 0; i < this.micDataArray.length; i++){\n                sum += Math.pow(this.micDataArray[i], 2);\n            }\n            let rms = Math.sqrt(sum / this.micDataArray.length);\n            // smooth the value, if it is descending\n            if (this._lastValue) {\n                rms = Math.max(rms, this._lastValue * 0.6);\n            }\n            this._lastValue = rms;\n\n            // Scale the measurement so it's more sensitive to quieter sounds\n            rms *= 1.63;\n            rms = Math.sqrt(rms);\n            // Scale it up to 0-100 and round\n            rms = Math.round(rms * 100);\n            // Prevent it from going above 100\n            rms = Math.min(rms, 100);\n            return rms;\n        }\n\n        // if there is no microphone input, return -1\n        return -1;\n    }\n}\n\nmodule.exports = Loudness;\n","const log = require('./log');\n\n/**\n * A symbol indicating all targets are to be effected.\n * @const {string}\n */\nconst ALL_TARGETS = '*';\n\nclass SoundBank {\n    /**\n     * A bank of sounds that can be played.\n     * @constructor\n     * @param {AudioEngine} audioEngine - related AudioEngine\n     * @param {EffectChain} effectChainPrime - original EffectChain cloned for\n     *     playing sounds\n     */\n    constructor (audioEngine, effectChainPrime) {\n        /**\n         * AudioEngine this SoundBank is related to.\n         * @type {AudioEngine}\n         */\n        this.audioEngine = audioEngine;\n\n        /**\n         * Map of ids to soundPlayers.\n         * @type {object<SoundPlayer>}\n         */\n        this.soundPlayers = {};\n\n        /**\n         * Map of targets by sound id.\n         * @type {Map<string, Target>}\n         */\n        this.playerTargets = new Map();\n\n        /**\n         * Map of effect chains by sound id.\n         * @type {Map<string, EffectChain}\n         */\n        this.soundEffects = new Map();\n\n        /**\n         * Original EffectChain cloned for every playing sound.\n         * @type {EffectChain}\n         */\n        this.effectChainPrime = effectChainPrime;\n    }\n\n    /**\n     * Add a sound player instance likely from AudioEngine.decodeSoundPlayer\n     * @param {SoundPlayer} soundPlayer - SoundPlayer to add\n     */\n    addSoundPlayer (soundPlayer) {\n        this.soundPlayers[soundPlayer.id] = soundPlayer;\n    }\n\n    /**\n     * Get a sound player by id.\n     * @param {string} soundId - sound to look for\n     * @returns {SoundPlayer} instance of sound player for the id\n     */\n    getSoundPlayer (soundId) {\n        if (!this.soundPlayers[soundId]) {\n            log.error(`SoundBank.getSoundPlayer(${soundId}): called missing sound in bank`);\n        }\n\n        return this.soundPlayers[soundId];\n    }\n\n    /**\n     * Get a sound EffectChain by id.\n     * @param {string} sound - sound to look for an EffectChain\n     * @returns {EffectChain} available EffectChain for this id\n     */\n    getSoundEffects (sound) {\n        if (!this.soundEffects.has(sound)) {\n            this.soundEffects.set(sound, this.effectChainPrime.clone());\n        }\n\n        return this.soundEffects.get(sound);\n    }\n\n    /**\n     * Play a sound.\n     * @param {Target} target - Target to play for\n     * @param {string} soundId - id of sound to play\n     * @returns {Promise} promise that resolves when the sound finishes playback\n     */\n    playSound (target, soundId) {\n        const effects = this.getSoundEffects(soundId);\n        const player = this.getSoundPlayer(soundId);\n\n        if (this.playerTargets.get(soundId) !== target) {\n            // make sure to stop the old sound, effectively \"forking\" the output\n            // when the target switches before we adjust it's effects\n            player.stop();\n        }\n\n        this.playerTargets.set(soundId, target);\n        effects.addSoundPlayer(player);\n        effects.setEffectsFromTarget(target);\n        player.connect(effects);\n\n        player.play();\n\n        return player.finished();\n    }\n\n    /**\n     * Set the effects (pan, pitch, and volume) from values on the given target.\n     * @param {Target} target - target to set values from\n     */\n    setEffects (target) {\n        this.playerTargets.forEach((playerTarget, key) => {\n            if (playerTarget === target) {\n                this.getSoundEffects(key).setEffectsFromTarget(target);\n            }\n        });\n    }\n\n    /**\n     * Stop playback of sound by id if was lasted played by the target.\n     * @param {Target} target - target to check if it last played the sound\n     * @param {string} soundId - id of the sound to stop\n     */\n    stop (target, soundId) {\n        if (this.playerTargets.get(soundId) === target) {\n            this.soundPlayers[soundId].stop();\n        }\n    }\n\n    /**\n     * Stop all sounds for all targets or a specific target.\n     * @param {Target|string} target - a symbol for all targets or the target\n     *     to stop sounds for\n     */\n    stopAllSounds (target = ALL_TARGETS) {\n        this.playerTargets.forEach((playerTarget, key) => {\n            if (target === ALL_TARGETS || playerTarget === target) {\n                this.getSoundPlayer(key).stop();\n            }\n        });\n    }\n\n    /**\n     * Dispose of all EffectChains and SoundPlayers.\n     */\n    dispose () {\n        this.playerTargets.clear();\n        this.soundEffects.forEach(effects => effects.dispose());\n        this.soundEffects.clear();\n        for (const soundId in this.soundPlayers) {\n            if (this.soundPlayers.hasOwnProperty(soundId)) {\n                this.soundPlayers[soundId].dispose();\n            }\n        }\n        this.soundPlayers = {};\n    }\n\n}\n\nmodule.exports = SoundBank;\n","const {EventEmitter} = require('events');\n\nconst VolumeEffect = require('./effects/VolumeEffect');\n\n/**\n * Name of event that indicates playback has ended.\n * @const {string}\n */\nconst ON_ENDED = 'ended';\n\nclass SoundPlayer extends EventEmitter {\n    /**\n     * Play sounds that stop without audible clipping.\n     *\n     * @param {AudioEngine} audioEngine - engine to play sounds on\n     * @param {object} data - required data for sound playback\n     * @param {string} data.id - a unique id for this sound\n     * @param {ArrayBuffer} data.buffer - buffer of the sound's waveform to play\n     * @constructor\n     */\n    constructor (audioEngine, {id, buffer}) {\n        super();\n\n        /**\n         * Unique sound identifier set by AudioEngine.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * AudioEngine creating this sound player.\n         * @type {AudioEngine}\n         */\n        this.audioEngine = audioEngine;\n\n        /**\n         * Decoded audio buffer from audio engine for playback.\n         * @type {AudioBuffer}\n         */\n        this.buffer = buffer;\n\n        /**\n         * Output audio node.\n         * @type {AudioNode}\n         */\n        this.outputNode = null;\n\n        /**\n         * VolumeEffect used to fade out playing sounds when stopping them.\n         * @type {VolumeEffect}\n         */\n        this.volumeEffect = null;\n\n\n        /**\n         * Target engine, effect, or chain this player directly connects to.\n         * @type {AudioEngine|Effect|EffectChain}\n         */\n        this.target = null;\n\n        /**\n         * Internally is the SoundPlayer initialized with at least its buffer\n         * source node and output node.\n         * @type {boolean}\n         */\n        this.initialized = false;\n\n        /**\n         * Is the sound playing or starting to play?\n         * @type {boolean}\n         */\n        this.isPlaying = false;\n\n        /**\n         * Timestamp sound is expected to be starting playback until. Once the\n         * future timestamp is reached the sound is considered to be playing\n         * through the audio hardware and stopping should fade out instead of\n         * cutting off playback.\n         * @type {number}\n         */\n        this.startingUntil = 0;\n\n        /**\n         * Rate to play back the audio at.\n         * @type {number}\n         */\n        this.playbackRate = 1;\n\n        // handleEvent is a EventTarget api for the DOM, however the\n        // web-audio-test-api we use uses an addEventListener that isn't\n        // compatable with object and requires us to pass this bound function\n        // instead\n        this.handleEvent = this.handleEvent.bind(this);\n    }\n\n    /**\n     * Is plaback currently starting?\n     * @type {boolean}\n     */\n    get isStarting () {\n        return this.isPlaying && this.startingUntil > this.audioEngine.currentTime;\n    }\n\n    /**\n     * Handle any event we have told the output node to listen for.\n     * @param {Event} event - dom event to handle\n     */\n    handleEvent (event) {\n        if (event.type === ON_ENDED) {\n            this.onEnded();\n        }\n    }\n\n    /**\n     * Event listener for when playback ends.\n     */\n    onEnded () {\n        this.emit('stop');\n\n        this.isPlaying = false;\n    }\n\n    /**\n     * Create the buffer source node during initialization or secondary\n     * playback.\n     */\n    _createSource () {\n        if (this.outputNode !== null) {\n            this.outputNode.removeEventListener(ON_ENDED, this.handleEvent);\n            this.outputNode.disconnect();\n        }\n\n        this.outputNode = this.audioEngine.audioContext.createBufferSource();\n        this.outputNode.playbackRate.value = this.playbackRate;\n        this.outputNode.buffer = this.buffer;\n\n        this.outputNode.addEventListener(ON_ENDED, this.handleEvent);\n\n        if (this.target !== null) {\n            this.connect(this.target);\n        }\n    }\n\n    /**\n     * Initialize the player for first playback.\n     */\n    initialize () {\n        this.initialized = true;\n\n        this._createSource();\n    }\n\n    /**\n     * Connect the player to the engine or an effect chain.\n     * @param {object} target - object to connect to\n     * @returns {object} - return this sound player\n     */\n    connect (target) {\n        if (target === this.volumeEffect) {\n            this.outputNode.disconnect();\n            this.outputNode.connect(this.volumeEffect.getInputNode());\n            return;\n        }\n\n        this.target = target;\n\n        if (!this.initialized) {\n            return;\n        }\n\n        if (this.volumeEffect === null) {\n            this.outputNode.disconnect();\n            this.outputNode.connect(target.getInputNode());\n        } else {\n            this.volumeEffect.connect(target);\n        }\n\n        return this;\n    }\n\n    /**\n     * Teardown the player.\n     */\n    dispose () {\n        if (!this.initialized) {\n            return;\n        }\n\n        this.stopImmediately();\n\n        if (this.volumeEffect !== null) {\n            this.volumeEffect.dispose();\n            this.volumeEffect = null;\n        }\n\n        this.outputNode.disconnect();\n        this.outputNode = null;\n\n        this.target = null;\n\n        this.initialized = false;\n    }\n\n    /**\n     * Take the internal state of this player and create a new player from\n     * that. Restore the state of this player to that before its first playback.\n     *\n     * The returned player can be used to stop the original playback or\n     * continue it without manipulation from the original player.\n     *\n     * @returns {SoundPlayer} - new SoundPlayer with old state\n     */\n    take () {\n        if (this.outputNode) {\n            this.outputNode.removeEventListener(ON_ENDED, this.handleEvent);\n        }\n\n        const taken = new SoundPlayer(this.audioEngine, this);\n        taken.playbackRate = this.playbackRate;\n        if (this.isPlaying) {\n            taken.startingUntil = this.startingUntil;\n            taken.isPlaying = this.isPlaying;\n            taken.initialized = this.initialized;\n            taken.outputNode = this.outputNode;\n            taken.outputNode.addEventListener(ON_ENDED, taken.handleEvent);\n            taken.volumeEffect = this.volumeEffect;\n            if (taken.volumeEffect) {\n                taken.volumeEffect.audioPlayer = taken;\n            }\n            if (this.target !== null) {\n                taken.connect(this.target);\n            }\n\n            this.emit('stop');\n            taken.emit('play');\n        }\n\n        this.outputNode = null;\n        this.volumeEffect = null;\n        this.initialized = false;\n        this.startingUntil = 0;\n        this.isPlaying = false;\n\n        return taken;\n    }\n\n    /**\n     * Start playback for this sound.\n     *\n     * If the sound is already playing it will stop playback with a quick fade\n     * out.\n     */\n    play () {\n        if (this.isStarting) {\n            this.emit('stop');\n            this.emit('play');\n            return;\n        }\n\n        if (this.isPlaying) {\n            this.stop();\n        }\n\n        if (this.initialized) {\n            this._createSource();\n        } else {\n            this.initialize();\n        }\n\n        this.outputNode.start();\n\n        this.isPlaying = true;\n\n        const {currentTime, DECAY_DURATION} = this.audioEngine;\n        this.startingUntil = currentTime + DECAY_DURATION;\n\n        this.emit('play');\n    }\n\n    /**\n     * Stop playback after quickly fading out.\n     */\n    stop () {\n        if (!this.isPlaying) {\n            return;\n        }\n\n        // always do a manual stop on a taken / volume effect fade out sound\n        // player take will emit \"stop\" as well as reset all of our playing\n        // statuses / remove our nodes / etc\n        const taken = this.take();\n        taken.volumeEffect = new VolumeEffect(taken.audioEngine, taken, null);\n\n        taken.volumeEffect.connect(taken.target);\n        // volumeEffect will recursively connect to us if it needs to, so this\n        // happens too:\n        // taken.connect(taken.volumeEffect);\n\n        taken.finished().then(() => taken.dispose());\n\n        taken.volumeEffect.set(0);\n        const {currentTime, DECAY_DURATION} = this.audioEngine;\n        taken.outputNode.stop(currentTime + DECAY_DURATION);\n    }\n\n    /**\n     * Stop immediately without fading out. May cause audible clipping.\n     */\n    stopImmediately () {\n        if (!this.isPlaying) {\n            return;\n        }\n\n        this.outputNode.stop();\n\n        this.isPlaying = false;\n        this.startingUntil = 0;\n\n        this.emit('stop');\n    }\n\n    /**\n     * Return a promise that resolves when the sound next finishes.\n     * @returns {Promise} - resolves when the sound finishes\n     */\n    finished () {\n        return new Promise(resolve => {\n            this.once('stop', resolve);\n        });\n    }\n\n    /**\n     * Set the sound's playback rate.\n     * @param {number} value - playback rate. Default is 1.\n     */\n    setPlaybackRate (value) {\n        this.playbackRate = value;\n\n        if (this.initialized) {\n            this.outputNode.playbackRate.value = value;\n        }\n    }\n}\n\nmodule.exports = SoundPlayer;\n","// StartAudioContext assumes that we are in a window/document setting and messes with the unit\n// tests, this is our own version just checking to see if we have a global document to listen\n// to before we even try to \"start\" it.  Our test api audio context is started by default.\nconst StartAudioContext = require('startaudiocontext');\n\nmodule.exports = function (context) {\n    if (typeof document !== 'undefined') {\n        return StartAudioContext(context);\n    }\n};\n","/**\n * An effect on an AudioPlayer and all its SoundPlayers.\n */\nclass Effect {\n     /**\n      * @param {AudioEngine} audioEngine - audio engine this runs with\n      * @param {AudioPlayer} audioPlayer - audio player this affects\n      * @param {Effect} lastEffect - effect in the chain before this one\n      * @constructor\n      */\n    constructor (audioEngine, audioPlayer, lastEffect) {\n        this.audioEngine = audioEngine;\n        this.audioPlayer = audioPlayer;\n        this.lastEffect = lastEffect;\n\n        this.value = this.DEFAULT_VALUE;\n\n        this.initialized = false;\n\n        this.inputNode = null;\n        this.outputNode = null;\n\n        this.target = null;\n    }\n\n    /**\n     * Return the name of the effect.\n     * @type {string}\n     */\n    get name () {\n        throw new Error(`${this.constructor.name}.name is not implemented`);\n    }\n\n    /**\n     * Default value to set the Effect to when constructed and when clear'ed.\n     * @const {number}\n     */\n    get DEFAULT_VALUE () {\n        return 0;\n    }\n\n    /**\n     * Should the effect be connected to the audio graph?\n     * The pitch effect is an example that does not need to be patched in.\n     * Instead of affecting the graph it affects the player directly.\n     * @return {boolean} is the effect affecting the graph?\n     */\n    get _isPatch () {\n        return this.initialized && (this.value !== this.DEFAULT_VALUE || this.audioPlayer === null);\n    }\n\n    /**\n     * Get the input node.\n     * @return {AudioNode} - audio node that is the input for this effect\n     */\n    getInputNode () {\n        if (this._isPatch) {\n            return this.inputNode;\n        }\n        return this.target.getInputNode();\n    }\n\n    /**\n     * Initialize the Effect.\n     * Effects start out uninitialized. Then initialize when they are first set\n     * with some value.\n     * @throws {Error} throws when left unimplemented\n     */\n    initialize () {\n        throw new Error(`${this.constructor.name}.initialize is not implemented.`);\n    }\n\n    /**\n     * Set the effects value.\n     * @private\n     * @param {number} value - new value to set effect to\n     */\n    _set () {\n        throw new Error(`${this.constructor.name}._set is not implemented.`);\n    }\n\n    /**\n     * Set the effects value.\n     * @param {number} value - new value to set effect to\n     */\n    set (value) {\n        // Initialize the node on first set.\n        if (!this.initialized) {\n            this.initialize();\n        }\n\n        // Store whether the graph should currently affected by this effect.\n        const wasPatch = this._isPatch;\n        if (wasPatch) {\n            this._lastPatch = this.audioEngine.currentTime;\n        }\n\n        // Call the internal implementation per this Effect.\n        if (value !== this.value) {\n            this._set(value);\n        }\n\n        // Connect or disconnect from the graph if this now applies or no longer\n        // applies an effect.\n        if (this._isPatch !== wasPatch && this.target !== null) {\n            this.connect(this.target);\n        }\n    }\n\n    /**\n     * Update the effect for changes in the audioPlayer.\n     */\n    update () {}\n\n    /**\n     * Clear the value back to the default.\n     */\n    clear () {\n        this.set(this.DEFAULT_VALUE);\n    }\n\n    /**\n     * Connnect this effect's output to another audio node\n     * @param {object} target - target whose node to should be connected\n     */\n    connect (target) {\n        if (target === null) {\n            throw new Error('target may not be null');\n        }\n\n        const checkForCircularReference = subtarget => {\n            if (subtarget) {\n                if (subtarget === this) {\n                    return true;\n                }\n                return checkForCircularReference(subtarget.target);\n            }\n        };\n        if (checkForCircularReference(target)) {\n            throw new Error('Effect cannot connect to itself');\n        }\n\n        this.target = target;\n\n        if (this.outputNode !== null) {\n            this.outputNode.disconnect();\n        }\n\n        if (this._isPatch || this._lastPatch + this.audioEngine.DECAY_DURATION < this.audioEngine.currentTime) {\n            this.outputNode.connect(target.getInputNode());\n        }\n\n        if (this.lastEffect === null) {\n            if (this.audioPlayer !== null) {\n                this.audioPlayer.connect(this);\n            }\n        } else {\n            this.lastEffect.connect(this);\n        }\n    }\n\n    /**\n     * Clean up and disconnect audio nodes.\n     */\n    dispose () {\n        this.inputNode = null;\n        this.outputNode = null;\n        this.target = null;\n\n        this.initialized = false;\n    }\n}\n\nmodule.exports = Effect;\n","class EffectChain {\n    /**\n     * Chain of effects that can be applied to a group of SoundPlayers.\n     * @param {AudioEngine} audioEngine - engine whose effects these belong to\n     * @param {Array<Effect>} effects - array of Effect classes to construct\n     */\n    constructor (audioEngine, effects) {\n        /**\n         * AudioEngine whose effects these belong to.\n         * @type {AudioEngine}\n         */\n        this.audioEngine = audioEngine;\n\n        /**\n         * Node incoming connections will attach to. This node than connects to\n         * the items in the chain which finally connect to some output.\n         * @type {AudioNode}\n         */\n        this.inputNode = this.audioEngine.audioContext.createGain();\n\n        /**\n         * List of Effect types to create.\n         * @type {Array<Effect>}\n         */\n        this.effects = effects;\n\n        // Effects are instantiated in reverse so that the first refers to the\n        // second, the second refers to the third, etc and the last refers to\n        // null.\n        let lastEffect = null;\n        /**\n         * List of instantiated Effects.\n         * @type {Array<Effect>}\n         */\n        this._effects = effects\n            .reverse()\n            .map(Effect => {\n                const effect = new Effect(audioEngine, this, lastEffect);\n                this[effect.name] = effect;\n                lastEffect = effect;\n                return effect;\n            })\n            .reverse();\n\n        /**\n         * First effect of this chain.\n         * @type {Effect}\n         */\n        this.firstEffect = this._effects[0];\n\n        /**\n         * Last effect of this chain.\n         * @type {Effect}\n         */\n        this.lastEffect = this._effects[this._effects.length - 1];\n\n        /**\n         * A set of players this chain is managing.\n         */\n        this._soundPlayers = new Set();\n    }\n\n    /**\n     * Create a clone of the EffectChain.\n     * @returns {EffectChain} a clone of this EffectChain\n     */\n    clone () {\n        const chain = new EffectChain(this.audioEngine, this.effects);\n        if (this.target) {\n            chain.connect(this.target);\n        }\n        return chain;\n    }\n\n    /**\n     * Add a sound player.\n     * @param {SoundPlayer} soundPlayer - a sound player to manage\n     */\n    addSoundPlayer (soundPlayer) {\n        if (!this._soundPlayers.has(soundPlayer)) {\n            this._soundPlayers.add(soundPlayer);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove a sound player.\n     * @param {SoundPlayer} soundPlayer - a sound player to stop managing\n     */\n    removeSoundPlayer (soundPlayer) {\n        this._soundPlayers.remove(soundPlayer);\n    }\n\n    /**\n     * Get the audio input node.\n     * @returns {AudioNode} audio node the upstream can connect to\n     */\n    getInputNode () {\n        return this.inputNode;\n    }\n\n    /**\n     * Connnect this player's output to another audio node.\n     * @param {object} target - target whose node to should be connected\n     */\n    connect (target) {\n        const {firstEffect, lastEffect} = this;\n\n        if (target === lastEffect) {\n            this.inputNode.disconnect();\n            this.inputNode.connect(lastEffect.getInputNode());\n\n            return;\n        } else if (target === firstEffect) {\n            return;\n        }\n\n        this.target = target;\n\n        firstEffect.connect(target);\n    }\n\n    /**\n     * Array of SoundPlayers managed by this EffectChain.\n     * @returns {Array<SoundPlayer>} sound players managed by this chain\n     */\n    getSoundPlayers () {\n        return [...this._soundPlayers];\n    }\n\n    /**\n     * Set Effect values with named values on target.soundEffects if it exist\n     * and then from target itself.\n     * @param {Target} target - target to set values from\n     */\n    setEffectsFromTarget (target) {\n        this._effects.forEach(effect => {\n            if ('soundEffects' in target && effect.name in target.soundEffects) {\n                effect.set(target.soundEffects[effect.name]);\n            } else if (effect.name in target) {\n                effect.set(target[effect.name]);\n            }\n        });\n    }\n\n    /**\n     * Set an effect value by its name.\n     * @param {string} effect - effect name to change\n     * @param {number} value - value to set effect to\n     */\n    set (effect, value) {\n        if (effect in this) {\n            this[effect].set(value);\n        }\n    }\n\n    /**\n     * Update managed sound players with the effects on this chain.\n     */\n    update () {\n        this._effects.forEach(effect => effect.update());\n    }\n\n    /**\n     * Clear all effects to their default values.\n     */\n    clear () {\n        this._effects.forEach(effect => effect.clear());\n    }\n\n    /**\n     * Dispose of all effects in this chain. Nothing is done to managed\n     * SoundPlayers.\n     */\n    dispose () {\n        this._soundPlayers = null;\n        this._effects.forEach(effect => effect.dispose());\n        this._effects = null;\n    }\n}\n\nmodule.exports = EffectChain;\n","const Effect = require('./Effect');\n\n/**\n * A pan effect, which moves the sound to the left or right between the speakers\n * Effect value of -100 puts the audio entirely on the left channel,\n * 0 centers it, 100 puts it on the right.\n */\nclass PanEffect extends Effect {\n    /**\n     * @param {AudioEngine} audioEngine - audio engine this runs with\n     * @param {AudioPlayer} audioPlayer - audio player this affects\n     * @param {Effect} lastEffect - effect in the chain before this one\n     * @constructor\n     */\n    constructor (audioEngine, audioPlayer, lastEffect) {\n        super(audioEngine, audioPlayer, lastEffect);\n\n        this.leftGain = null;\n        this.rightGain = null;\n        this.channelMerger = null;\n    }\n\n    /**\n     * Return the name of the effect.\n     * @type {string}\n     */\n    get name () {\n        return 'pan';\n    }\n\n    /**\n     * Initialize the Effect.\n     * Effects start out uninitialized. Then initialize when they are first set\n     * with some value.\n     * @throws {Error} throws when left unimplemented\n     */\n    initialize () {\n        const audioContext = this.audioEngine.audioContext;\n\n        this.inputNode = audioContext.createGain();\n        this.leftGain = audioContext.createGain();\n        this.rightGain = audioContext.createGain();\n        this.channelMerger = audioContext.createChannelMerger(2);\n        this.outputNode = this.channelMerger;\n\n        this.inputNode.connect(this.leftGain);\n        this.inputNode.connect(this.rightGain);\n        this.leftGain.connect(this.channelMerger, 0, 0);\n        this.rightGain.connect(this.channelMerger, 0, 1);\n\n        this.initialized = true;\n    }\n\n    /**\n     * Set the effect value\n     * @param {number} value - the new value to set the effect to\n     */\n    _set (value) {\n        this.value = value;\n\n        // Map the scratch effect value (-100 to 100) to (0 to 1)\n        const p = (value + 100) / 200;\n\n        // Use trig functions for equal-loudness panning\n        // See e.g. https://docs.cycling74.com/max7/tutorials/13_panningchapter01\n        const leftVal = Math.cos(p * Math.PI / 2);\n        const rightVal = Math.sin(p * Math.PI / 2);\n\n        const {currentTime, DECAY_WAIT, DECAY_DURATION} = this.audioEngine;\n        this.leftGain.gain.setTargetAtTime(leftVal, currentTime + DECAY_WAIT, DECAY_DURATION);\n        this.rightGain.gain.setTargetAtTime(rightVal, currentTime + DECAY_WAIT, DECAY_DURATION);\n    }\n\n    /**\n     * Clean up and disconnect audio nodes.\n     */\n    dispose () {\n        if (!this.initialized) {\n            return;\n        }\n\n        this.inputNode.disconnect();\n        this.leftGain.disconnect();\n        this.rightGain.disconnect();\n        this.channelMerger.disconnect();\n\n        this.inputNode = null;\n        this.leftGain = null;\n        this.rightGain = null;\n        this.channelMerger = null;\n        this.outputNode = null;\n        this.target = null;\n\n        this.initialized = false;\n    }\n}\n\nmodule.exports = PanEffect;\n","const Effect = require('./Effect');\n\n/**\n * A pitch change effect, which changes the playback rate of the sound in order\n * to change its pitch: reducing the playback rate lowers the pitch, increasing\n * the rate raises the pitch. The duration of the sound is also changed.\n *\n * Changing the value of the pitch effect by 10 causes a change in pitch by 1\n * semitone (i.e. a musical half-step, such as the difference between C and C#)\n * Changing the pitch effect by 120 changes the pitch by one octave (12\n * semitones)\n *\n * The value of this effect is not clamped (i.e. it is typically between -120\n * and 120, but can be set much higher or much lower, with weird and fun\n * results). We should consider what extreme values to use for clamping it.\n *\n * Note that this effect functions differently from the other audio effects. It\n * is not part of a chain of audio nodes. Instead, it provides a way to set the\n * playback on one SoundPlayer or a group of them.\n */\nclass PitchEffect extends Effect {\n    /**\n     * @param {AudioEngine} audioEngine - audio engine this runs with\n     * @param {AudioPlayer} audioPlayer - audio player this affects\n     * @param {Effect} lastEffect - effect in the chain before this one\n     * @constructor\n     */\n    constructor (audioEngine, audioPlayer, lastEffect) {\n        super(audioEngine, audioPlayer, lastEffect);\n\n        /**\n         * The playback rate ratio\n         * @type {Number}\n         */\n        this.ratio = 1;\n    }\n\n    /**\n     * Return the name of the effect.\n     * @type {string}\n     */\n    get name () {\n        return 'pitch';\n    }\n\n    /**\n     * Should the effect be connected to the audio graph?\n     * @return {boolean} is the effect affecting the graph?\n     */\n    get _isPatch () {\n        return false;\n    }\n\n    /**\n     * Get the input node.\n     * @return {AudioNode} - audio node that is the input for this effect\n     */\n    getInputNode () {\n        return this.target.getInputNode();\n    }\n\n    /**\n     * Initialize the Effect.\n     * Effects start out uninitialized. Then initialize when they are first set\n     * with some value.\n     * @throws {Error} throws when left unimplemented\n     */\n    initialize () {\n        this.initialized = true;\n    }\n\n    /**\n     * Set the effect value.\n     * @param {number} value - the new value to set the effect to\n     */\n    _set (value) {\n        this.value = value;\n        this.ratio = this.getRatio(this.value);\n        this.updatePlayers(this.audioPlayer.getSoundPlayers());\n    }\n\n    /**\n     * Update the effect for changes in the audioPlayer.\n     */\n    update () {\n        this.updatePlayers(this.audioPlayer.getSoundPlayers());\n    }\n\n    /**\n     * Compute the playback ratio for an effect value.\n     * The playback ratio is scaled so that a change of 10 in the effect value\n     * gives a change of 1 semitone in the ratio.\n     * @param {number} val - an effect value\n     * @returns {number} a playback ratio\n     */\n    getRatio (val) {\n        const interval = val / 10;\n        // Convert the musical interval in semitones to a frequency ratio\n        return Math.pow(2, (interval / 12));\n    }\n\n    /**\n     * Update a sound player's playback rate using the current ratio for the\n     * effect\n     * @param {object} player - a SoundPlayer object\n     */\n    updatePlayer (player) {\n        player.setPlaybackRate(this.ratio);\n    }\n\n    /**\n     * Update a sound player's playback rate using the current ratio for the\n     * effect\n     * @param {object} players - a dictionary of SoundPlayer objects to update,\n     *     indexed by md5\n     */\n    updatePlayers (players) {\n        if (!players) return;\n\n        for (const id in players) {\n            if (players.hasOwnProperty(id)) {\n                this.updatePlayer(players[id]);\n            }\n        }\n    }\n}\n\nmodule.exports = PitchEffect;\n","const Effect = require('./Effect');\n\n/**\n * Affect the volume of an effect chain.\n */\nclass VolumeEffect extends Effect {\n    /**\n     * Default value to set the Effect to when constructed and when clear'ed.\n     * @const {number}\n     */\n    get DEFAULT_VALUE () {\n        return 100;\n    }\n\n    /**\n     * Return the name of the effect.\n     * @type {string}\n     */\n    get name () {\n        return 'volume';\n    }\n\n    /**\n     * Initialize the Effect.\n     * Effects start out uninitialized. Then initialize when they are first set\n     * with some value.\n     * @throws {Error} throws when left unimplemented\n     */\n    initialize () {\n        this.inputNode = this.audioEngine.audioContext.createGain();\n        this.outputNode = this.inputNode;\n\n        this.initialized = true;\n    }\n\n    /**\n     * Set the effects value.\n     * @private\n     * @param {number} value - new value to set effect to\n     */\n    _set (value) {\n        this.value = value;\n\n        const {gain} = this.outputNode;\n        const {currentTime, DECAY_DURATION} = this.audioEngine;\n        gain.linearRampToValueAtTime(value / 100, currentTime + DECAY_DURATION);\n    }\n\n    /**\n     * Clean up and disconnect audio nodes.\n     */\n    dispose () {\n        if (!this.initialized) {\n            return;\n        }\n\n        this.outputNode.disconnect();\n\n        this.inputNode = null;\n        this.outputNode = null;\n        this.target = null;\n\n        this.initialized = false;\n    }\n}\n\nmodule.exports = VolumeEffect;\n","/**\n * @fileOverview Scratch Audio is divided into a single AudioEngine, that\n * handles global functionality, and AudioPlayers, belonging to individual\n * sprites and clones.\n */\n\nconst AudioEngine = require('./AudioEngine');\n\nmodule.exports = AudioEngine;\n","const minilog = require('minilog');\nminilog.enable();\n\nmodule.exports = minilog('scratch-audioengine');\n","/**\n * @fileoverview UID generator, from Blockly.\n */\n\n/**\n * Legal characters for the unique ID.\n * Should be all on a US keyboard.  No XML special characters or control codes.\n * Removed $ due to issue 251.\n * @private\n */\nconst soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' +\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n * @return {string} A globally unique ID string.\n */\nconst uid = function () {\n    const length = 20;\n    const soupLength = soup_.length;\n    const id = [];\n    for (let i = 0; i < length; i++) {\n        id[i] = soup_.charAt(Math.random() * soupLength);\n    }\n    return id.join('');\n};\n\nmodule.exports = uid;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA,WAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;;;;AAIA;AACA;AAQA;;;;AAIA;AACA;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;AAgBA;;;;;;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAzKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;;;AAkKA;;;;;;;;;;;;;;;;;;ACvPA;AACA;;;;;;;;;;;;;;;;AAgBA;AAKA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAmBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;AAxFA;AACA;AACA;AACA;AACA;;;;;;AAKA;AACA;AACA;AACA;;;;;;AA+EA;;;;;;;;;;;;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;;;;;;AAKA;AACA;AAAA;AACA;AADA;AACA;AAAA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;;;AA+CA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;AA3KA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;;;;;;AAqIA;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;ACjKA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AACA;;;;;;;;;AASA;AAAA;AAAA;AACA;AADA;AACA;AAEA;;;;AAHA;AACA;AAMA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAxEA;AAyEA;AACA;AACA;;;;;;;;;;AAQA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAAA;AAAA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAlBA;AAAA;AAAA;AACA;AAmBA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAlPA;AACA;AACA;;;;AA3FA;AACA;AA6UA;;;;;;;;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACTA;;;AAGA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AA0BA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA7IA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;;;;AA4HA;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;ACrLA;AACA;AACA;;;;;;AAKA;;;AACA;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAEA;AACA;AACA;AALA;AAMA;AACA;AACA;;;;;;;;;;AAQA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAAA;AAAA;AAAA;AACA;AAWA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AApEA;AACA;AACA;;;;AArBA;AACA;AAyFA;;;;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAkBA;;;AACA;;;;;;AAMA;AAAA;AACA;AAEA;;;;AAHA;AACA;AAMA;AAPA;AAQA;AACA;AACA;;;;;;;;;;AAgBA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAnFA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;AA/BA;AACA;AA0GA;;;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;;;;AAGA;;;;;;;;;;;;;AAiBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAzDA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;AAfA;AACA;AA4DA;;;;;;;;;;;;;;AClEA;;;;;;AAMA;AACA;AACA;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;;;;;;;;;;;;;;ACHA;;;;AAIA;;;;;;AAMA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}